                     Postmaster ESMTP Server

The main configuration file resides in /etc/postmaster.cf:

  [core]
    logger              = syslog
    user-id             = "postmaster"
    group-id            = "nobody"
    pid-file            = "/var/run/postmaster.pid"
    spool-directory     = "/var/spool/mailqueue"
    local-mailer        = procmail

  [syslog]
    ident               = "postmaster"
    facility            = "mail"

  [logfile "system-wide-logfile"]
    file                = "/var/log/postmaster-%Y-%m-%d"

  [pipe "procmail"]
    exec                = "/usr/bin/procmail" "-f" "${MAIL_FROM}" "-d" "${RCPT_TO}"
    max_rcpt_to         = 16

  [relay "relay.example.org"]
    name                = relay.example.org     # redundant
    address             = 10.0.0.1
    address             = 10.0.0.2

  [smtpd "mx.example.net"]
    name                = mx.example.net        # redundant
    listen-port         = 25                    # default is mx.example.net:25
    routing-table       = extern

  [smtpd "localhost"]
    listen-port         = ipv6-localhost:submission   # ::1:587
    logger              = system-wide-logfile
    routing-table       = local-routes
    local-rcpt-to       = yes

  [route]
    postmaster                          joe
    postmaster@acme.example.net         postmaster
    postmaster@acme.example.org         postmaster

    file "/etc/postmaster.rt"

  [route "local-routes"]
    # simulate sendmail for processes that can connect to localhost
    root@         postmaster
    bin@          postmaster
    cron@         postmaster
    games@        postmaster

  [route "extern"]
    @example.com  @example.org
    @example.org  mx.example.net

The configuration is divided into sections. Every section assigns
an arbitrary number of variables and lasts until the end of the
file or until a new section is opened. The default section at the
beginning of the file is [route]. The '=' in variable assignments
is optional: "foo bar" and "foo = bar" mean the same thing.
Consequently, the routing section bodies

  @example.org    = @example.net
  joe@example.net = joe

and

  @example.org    @example.net
  joe@example.net joe

are equivalent.

Postmaster is interested in the following sections:

  [core]

    This section configures the low-level system layer of the
    postmaster daemon. These options have sensible compile-time
    defaults; it shouldn't be necessary to specify any of these
    values. Anyway, here they are:

    local-mailer = ident
      The default local mailer.

    spool-directory = "string"
      Path to the mail spool directory.

    user-id  = "string"
    group-id = "string"
      Setuid()/setgid() to ids after all listening ports have
      been bound. Postmaster does not require super-user
      privileges beyond binding to TCP port 25. Local mail
      deliver, however, typically does, so either postmaster is
      run as 'root' or the local mail back-end (i.e. procmail)
      needs an appropriate setuid bit.

    pid-file = "string"
      Write a PID file to this location.

    logger = ident
      The logging back-end of choice, the default typically
      being 'syslog'. The alternative is to write into a
      'logfile' target that's defined in this config file.

  [syslog]
    ident = "string"
      Configure the identifier to pass to openlog(3); defaults to
      "postmaster".

    facility = "string"
      Configure facility to pass to openlog(3); defaults to
      LOG_MAIL.

  [logfile ident]
    file = "string"
      Path to the log file. strftime(3) placeholders are
      expanded.

  [smtpd ident]
    logger = ident
    listen-port = "string"
    routing-table = "string"

  [pipe ident]

  [relay ident]

  [route ident]




What does Postmaster do?

  The individual components are an SMTP daemon, an SMTP client,
  and a spool manager. The spool manager receives e-mail from the
  daemon and dispatches it to an external local mailer. In case
  of relaying, this local mailer could be the Postmaster SMTP
  client, but it might also be procmail, mailx, Petidomo, or any
  other suitable e-mail back-end. Postmaster's configuration is
  essentially a routing table that maps an e-mail address to a
  local mailer.

  As far as the daemon is concerned, it speaks ESMTP with
  PIPELINING, 8BITMIME, and STARTTLS extensions. Commands the
  daemon does not support are HELP, TURN, SEND, SOML, SAML, and
  EXPN. VRFY is a tough question, see below.

  An additional component that would be quite nice to have is a
  web-based configuration manager, particularly one that can
  manage the spool directory and query wild run-time statistics
  from the daemon too.


What about spam?

  In theory, the set of configured addresses is the set of
  addresses the daemon accepts, but for spam protection it is
  necessary to build some sort of authentication callback into
  Postmaster -- a simple function that can reject incoming e-mail
  in the SMTP dialogue although it has a valid envelope and
  recipient. It might be nice to have a DSO interface to these
  kind of callbacks.

  Native SPF support in daemon via <http://www.libspf2.org/>.

  More sophisticated spam recognition is beyond the package's
  scope and belongs into the realm of local mailers.


What does the configuration file look like:

  It's typically found at /etc/postmaster.cf and looks a bit like
  sendmail's virtusertable:

  | // deliver to local mailbox using the default local mailer
  | joe.doe@example.org         joe
  |
  | // rewrite recipient address
  | joe.dow@example.org         jane.dow@example.org
  |
  | // if any target address fails, the entire RCPT TO fails
  | dow.joe@example.org         joe@example.net, joe@example.com
  |
  | // define domain name aliases
  | @example.com                @example.net
  |
  | // exact matches take precedence over the default match above
  | joe@example.com             joe.doe@example.com
  |
  | // do what sendmail does for members of /etc/passwd
  | info@                       propaganda@example.net

  Postmaster extends virtusertable's semantics by local mailer
  targets that are specified in a syntax similar to function
  calls:

  | // configure relaying
  | @acme.example.com           relay(10.0.0.1:587)
  |
  | // configure several smart hosts (in order of preference)
  | @                           relay(isp.example.net, 10.33.0.1)
  |
  | // we don't need no "..."-quoting of the argument
  | abuse@acme.example.com      pipe(/usr/bin/cat >/dev/null)




Should Postmaster support VRFY?

  The usefulness of the VRFY command in spam protection is hard
  to judge. From an SMTP server's perspective, it would be nice
  if an incoming RCPT TO could be validated on the spot in case
  the transaction leads to relaying. If the target MX says "no"
  to this address, it can be reject here too. This makes VRFY a
  useful command.

  On the other hand, there have been claims that spammers might
  abuse that command to validate their address lists. That point
  feels minor. It is not obvious why it might be an advantage if
  spammers send out millions of bogus RCPT TOs instead.
  Apparently that is supposed to slow them down? People have
  built entire anti-spam software around the notion of slowing
  spammers down (like honey traps, Teergruben, etc.), but it
  doesn't seem to work too well in practice, does it?

  When asked, sendmail says about VRFY:

  | 252 2.5.2 Cannot VRFY user; try RCPT to attempt delivery (or try finger)

  It sounds stupid -- and it is! -- but there is some truth in
  it. When relaying, it might be even better to open a real
  transaction on the spot, and to get that remote MX to confirm
  an RCPT TO before confirming our own RCPT TO to the client.

  One disadvantage of implementing VRFY is that it would have to
  be considered bad practice to say "yes" to a VRFY, but "no" to
  an RCPT TO for the same address later. That is bound to happen,
  however, because an address might in principle pass VRFY, but
  fail RCPT TO because of the prior MAIL FROM (which VRFY can't
  know).

  A good interpretation could be that VRFY may produce false
  positives but no false negatives. A reject is binding, but
  acceptance doesn't guarantee that the mail transaction itself
  will actually succeed.

  The best way to put it probably is that VRFY is redundant.

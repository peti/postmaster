<!-- Automagically generated by the ToDo program on Fri Feb  4 17:33:26 2005 -->
<todo version="0.1.18">
    <title>
        Postmaster
    </title>
    <note priority="veryhigh" time="1099264722" done="1099303821">
        figure out why mailid is assigned twice for mail from:&lt;&gt;
        <comment>
            fixed bug in impatient
        </comment>
    </note>
    <note priority="high" time="1098655722" done="1098737399">
        Handler needs a Handler(Status|State) field in Target.
        <comment>
            Implemented. We know have 5 handler status
            codes: Ready, Live, Succeeded, Failed,
            FailedPermanently. The Deliver event uses them
            to determine correct SmtpReply. The semantics
            are: If one target is okay, the whole data
            transaction is okay. If all fail permanently,
            the transaction fails permanently. Otherwise the
            transaction falis with a 4xx code.
        </comment>
    </note>
    <note priority="high" time="1098658162" done="1099014967">
        Need combinators to create targets (fwd, alias, etc.)
        <comment>
            done: 'relay' and 'pipe'
        </comment>
    </note>
    <note priority="high" time="1099253334" done="1107534743">
        Replace Val with Data.Dynamic
        <comment>
            code moved to MonadEnv module
        </comment>
    </note>
    <note priority="medium" time="1098325598" done="1098585670">
        Does the eventHandler have to set sessionState?
        <comment>
            No, it does not. handleDialog and handleData set
            the sessionState according to the results of
            smtpdFSM. The user callbacks should not (and in
            fact cannot) interfere.
        </comment>
    </note>
    <note priority="medium" time="1098329496" done="1098585655">
        Add "Greeting" event.
        <comment>
            Done. The event is triggered by runSmtpd before
            anything else happens. It can be used to
            initialize the SmtpdState for the rest of the
            session.
        </comment>
    </note>
    <note priority="medium" time="1098713602" done="1098738894">
        If "greeting" returns failure code, abort the connection.
        <comment>
            Implemented. Anything but 2xx will cause
            runSmtpd to drop the connection.
        </comment>
    </note>
    <note priority="medium" time="1098939046" done="1099015643">
        I need a better shutdown mechanism than fail
        <comment>
            done: reply 221 and 421 will drop the connection
        </comment>
    </note>
    <note priority="medium" time="1099013220" done="1099093120">
        Need 'closeTarget' to run before 'commitTarget'.
        <comment>
            implemented
        </comment>
    </note>
    <note priority="high" time="1098656254">
        We need a spooler.

        If the external handler returns an error, we cannot
        create a bounce message because we don't have the
        payload anymore! With sendmail as backend, this
        doesn't matter because sendmail does bounce the mail
        in case of an error, but we rather soon need a
        spooler that writes everything to disk, just in
        case. From there, a spool manager could retry
        delivery, etc.
    </note>
    <note priority="high" time="1098924318">
        smtpdMain has to protect accept with 'bracket'
    </note>
    <note priority="high" time="1099253001">
        Start shells with "set +e".
    </note>
    <note priority="high" time="1099253516">
        Model a generic stream processor through a Stream a datatype!
    </note>
    <link filename="blockio/.todo" priority="medium" time="0"/>
    <link filename="dns/.todo" priority="medium" time="0"/>
    <link filename="email/.todo" priority="medium" time="0"/>
    <link filename="syslog/.todo" priority="medium" time="0"/>
    <note priority="medium" time="1098329354">
        Log timeouts where they occur, not in runSmtpd.
    </note>
    <note priority="medium" time="1098589904">
        Need combinator to catch and log the usual exceptions.
    </note>
    <note priority="medium" time="1098656105">
        Add an "InetAddress" type for IPv4 and v6 addresses.

        Also, a class interface which allows to convert all
        kinds of IP-address representations hence and forth
        between my type and HostAddr, SockAddr, etc.
    </note>
    <note priority="medium" time="1098726128">
        Need function to generate received headers
    </note>
    <note priority="medium" time="1098748188">
        Avoid zombie processes by waiting for the child

        The changes in commitTarget (safeGetExitCode instead
        of waitForProcess) should fix that.

        There remains the case of the process aborting
        abnormally, or the I/O thread that holds the handle
        received an exception. I have a finalizer attached
        to the ExternHandle, which will kill, then wait for
        the child. Will see whether that helps.
    </note>
    <note priority="medium" time="1098894546">
        'smtpdMain' should expect a Socket, not a PortID.
    </note>
    <note priority="medium" time="1098944687">
        need debugEH-like wrapper to dump the environment
    </note>
    <note priority="medium" time="1099011048">
        Need CRLF conversion for local mailers.

        I have to convert CRLF to LF because some programs,
        like procmail, don't understand CRLF-ended lines.
        This is a job for the dataHandler, obviously. I just
        wonder how to trigger it! For every pipe? Just for
        procmail? Or do nothing and have people call

          #! /bin/sh --
          sed -e 's/^M$//' | /usr/bin/procmail $*

        instead? I need a more flexible Target type. There's
        no way around it. Ideally, a Target could be written
        completely outside of Postmaster, then this were the
        user's problem and not mine. That's the way to do
        it.
    </note>
    <note priority="medium" time="1099252968">
        write ts :: EnvT a -&gt; EnvT (Timestamped a)
    </note>
    <note priority="medium" time="1100044460">
        deny private addresses (as mx, too)
    </note>
    <note priority="medium" time="1107470824" done="1107534805">
        replace error with fail wherever possible
        <comment>
            done
        </comment>
    </note>
    <note priority="low" time="1098627718">
        Do "performGC &gt;&gt; yield" when resources run out.

        Although a Handle is garbage-collected in Haskell,
        it is not clear when the appropriate finalizer will
        be run! Thus, it might be a good idea to trigger an
        explicit garbage collection in case we've received
        an exception which signifies that system resources
        are unavailable. This applies to all kind of
        finalizer-based resource management. The only case
        in which the RTS will run the GC itself is when
        memory runs out. But other resources (file
        descriptors, etc.) don't do that.
    </note>
    <note priority="low" time="1098656192">
        Find out how RTS settings affect the performance.

        Does the event handler benefit from caching? Or do
        we benefit from aggressive GC because it keeps our
        memory footprint small and ensures all finalizers
        are run quickly? (Currently, only ExternalHandle
        depends on finalizers.)
    </note>
    <note priority="low" time="1098732401">
        Need a sub-monad class.

        I need a class which handles the case where the
        state of the outer monad contains the state of the
        inner monad. The class would contain glue code
        telling me how to get/put the state into the outer
        monads data type, and then a simple 'run' should
        suffice to call all sub-monads.

        Declaring "MonadState st" for every contained state
        might do the trick, but I need to allow undecidable
        instances to do that.

          instance (MonadState Config m)
            =&gt; MonadReader Callbacks m where
    </note>
    <note priority="low" time="1098754939">
        waitForProcess throws exceptions I have to catch

        Glynn Clements writes:

        &gt; Both [getProcessExitCode and waitForProcess]
        &gt; will throw an exception if the process
        &gt; terminated on a signal.

        I've fixed it now, I think. It is horrible:
        'safeWaitForProcess' basically busy-polls the status
        every 1/10 second with a 'timeout' and 'catch'
        wrapped around the whole computation. Processes that
        are terminated by signals will be mapped to "exit 1".

        It appears to be robust so far.
    </note>
    <note priority="low" time="1099006932">
        Batch procmail calls.

        Procmail's -d option allows more than one recipient.
        I need to support that in a useful way, but the
        current Target definition doesn't allow me to batch
        it, because -- in the general case -- I cannot batch
        pipe.
    </note>
    <note priority="low" time="1099252878">
        Make a prologue file for the haddock index page.
    </note>
    <note priority="low" time="1099253109">
        write combinator to catchALL and log all state etc. to disk
    </note>
    <note priority="low" time="1104539876">
        Need way to accept _all_ e-mail from trusted peers to avoid bounces.
    </note>
    <note priority="verylow" time="1097188529">
        Format log messages and map them to priorities.
    </note>
    <note priority="verylow" time="1099158901">
        Generally prefix internal functions with _.
    </note>
    <note priority="verylow" time="1099253172">
        A 'fallback' combinator: "try f e $ either default return" or so
    </note>
</todo>

*** Configure Postmaster

fmod REGEX is
  protecting STRING .
  sort RegEx .
  subsort String < RegEx .
endfm

fmod LIST is
  sort List .
  op []  : -> List [ctor] .
  op _,_ : List List -> List [assoc] .
  op [_] : List -> List [ctor] .
endfm

fmod TYPES is
  protecting QID .
  protecting REGEX .
  protecting LIST .

  --- A Qid is a variable, is a String
  subsort Qid < String .

  --- Concatenate two strings
  op __ : String String -> String [assoc prec 10] .

  --- Define lists of strings
  subsort String < List .

  sorts Mailbox IPv4Addr .
  subsorts IPv4Addr Mailbox < String .
  op user_   : Mailbox -> String .
  op domain_ : Mailbox -> String .
  op binary  : IPv4Addr -> String .
endfm

fmod COND is
  protecting TYPES .

  --- We support various conditional constructs
  sort Cond .
  op _==_ : String String -> Cond [ctor] .
  op _!=_ : String String -> Cond [ctor] .
  op not  : Cond -> Cond .
  op always : -> Cond [ctor] .
  op otherwise : -> Cond [ctor] .

  --- Regular expression matches
  op _=~_ : String RegEx -> Cond [ctor] .
  op _!~_ : String RegEx -> Cond [ctor] .

  --- The "matching part" of the last == or =~ operation
  --- may be accessed as $(0); =~ may provide further
  --- sub-results $(1), $(2), ...

  op $ : Nat -> String [ctor] .

  --- Match against lists

  op _== anyOf_ : String List -> Cond [ctor] .
  op _!= allOf_ : String List -> Cond [ctor] .

  op _=~ anyOf_ : String List -> Cond [ctor] .
  op _!~ allOf_ : String List -> Cond [ctor] .

  --- The resolver will put the result (if there is any) to
  --- $(0).

  sort RRType .
  ops A PTR MX : -> RRType [ctor] .
  op resolve__ : RRType String -> Cond [ctor] .

  --- Test whether someone is a local user.

  op isUser : String -> Cond [ctor] .
endfm

fmod ACTION is
  protecting TYPES .

  sort Action .
  op reply____ : Nat Nat Nat String -> Action .
  op reply____ : Nat Nat Nat List   -> Action .
endfm

fmod STATEMENT is
  protecting COND .
  protecting ACTION .

  sort Stmt .

  op _=>_ : Cond Action -> Stmt [ctor prec 60] .

  op define_=_   : Qid String       -> Stmt .
  op alter_=_->_ : Qid RegEx String -> Stmt .

  op define_=_   : Qid List   -> Stmt .
  op add__       : Qid String -> Stmt .
  op add__       : Qid List   -> Stmt .
  op remove__    : Qid String -> Stmt .
  op remove__    : Qid List   -> Stmt .
  op removeBy__  : Qid RegEx  -> Stmt .
  op map__       : Qid Stmt   -> Stmt .

  sort Hook .
  subsort Stmt < Hook .
  ops __ : Hook Hook -> Hook [assoc prec 70 format (d ni d)] .
  op {_} : Hook -> Action [format (++ni ni ni --)].
endfm

fmod PERSISTANT is
  protecting STATEMENT .

  --- Read a file into a list (so that you can define a
  --- variable) or write a list to a file.

  op readList_   : String -> List .
  op writeList__ : Qid String -> Stmt .
  op writeList__ : List String -> Stmt .

  --- Test whether a file exists.

  op fileExists_ : String -> Cond [ctor] .
endfm

fmod META is
  protecting PERSISTANT .

  op include_    : String -> Stmt .
endfm

fmod CONFIG is
  protecting STATEMENT .
  protecting PERSISTANT .
  protecting META .

  op pid        : -> String [ctor] .
  op myHelo     : -> String [ctor] .

  op peerHelo   : -> String [ctor] .
  op peerAddr   : -> IPv4Addr [ctor] .

  op from       : -> Mailbox [ctor] .
  op to         : -> Mailbox [ctor] .

  op mbox_      : String -> Action .
  op relay_     : String -> Action .
  op alias_     : String -> Action .
  op pipe_      : String -> Action .

  ops init greeting helo mail rcpt data : -> Hook .
endfm

fmod TEST is
  protecting CONFIG .

  ops crypto cryptodeliver : -> Hook .

  eq init =
    not (fileExists "/etc/mail/blacklist")
      => { writeList [] "/etc/mail/blacklist" }
    define 'blacklist = readList "/etc/mail/blacklist"
    define 'othermx = [ "research.cryp.to"
                      , "madcow.cryp.to"
                      , "peti.cryp.to"
                      ]
    remove 'othermx myHelo
    define 'localnames = readList "/etc/mail/local-host-names"
    .

  eq greeting =
    peerAddr == anyOf 'blacklist => reply 5 0 0 "nope"
    otherwise => reply 2 2 0 myHelo " Postmaster SMTP Daemon"
    .

  eq helo =
    peerHelo !~ "^\[.*\]$" =>
      {
      resolve A peerHelo =>
        reply 2 5 0 myHelo " Pleased to meet you."
      }
    otherwise =>
      reply 5 0 0 "Use a hostname or a literal for HELO, please."
    .

  eq mail =
    from !~ "(^$|@\[.*\])" =>
      {
      not (resolve MX domain from) =>
        {
        not (resolve A domain from) =>
          reply 5 0 0 "Cannot resolve " (domain from) "."
        }
      }
    otherwise => reply 2 5 0 from " ... sender ok"
    .

  eq rcpt =
    domain to =~ "^((peti|research|madcow)\\.)?cryp\\.to$" =>
      { crypto }

    domain to == "pfm-mainz.de" =>
      {
      user to == anyOf ["rbabel", "kruzifix"]
        => mbox "rbabel"
      }

    domain to == "polizei.net" => relay "10.1.1.1"

    domain to == "lists.cryp.to" =>
      {
      myHelo == "research.cryp.to" =>
        {
        user to == anyOf [ "party", "quam" ]
          => pipe ("petidomo --deliver=" $(0))
        }
      otherwise => relay "lists.cryp.to"
      }

    otherwise =>
      {
      add 'blacklist peerAddr
      writeList 'blacklist "/etc/mail/blacklist"
      always => reply 5 0 0 "nope"
      }
    .

  eq crypto =
    user to =~ "^(p|h)ostmaster$" => { cryptodeliver }
    user to =~ "^simons$" => { cryptodeliver }
    user to == "bach" => alias "bach@polizei.net"
    .

  eq cryptodeliver =
    domain to == anyOf 'othermx => relay (domain to)
    myHelo != "peti.cryp.to" => relay "peti.cryp.to"
    otherwise => mbox "simons"
    .

endfm

fmod TEST2 is
  protecting CONFIG .

  eq init =
    define 'localnames = readList "/etc/mail/local-host-names"
    .

  eq greeting =
    otherwise => reply 2 2 0 myHelo " Postmaster SMTP Daemon"
    .

  eq helo =
    always => reply 2 5 0 myHelo " Pleased to meet you."
    .

  eq mail =
    always => reply 2 5 0 from " ... sender ok"
    .

  eq rcpt =
    domain to == anyOf 'localnames =>
      {
      isUser (user to) =>
        {
        fileExists "/home/" (user to) "/.postmaster.cf" =>
          {
          include "/home/" (user to) "/.postmaster.cf"
          always => reply 4 5 0 "configuration error"
          }
        otherwise => reply 5 5 0 "user does not receive mail"
        }
      }
    otherwise => reply 5 5 0 "user unknown"
    .

endfm

fmod COMPAT is
  protecting CONFIG .

  --- Read sendmail files and configure ourselves
  --- accordingly.

  op readAliases_  : String -> Hook .
  op readVirtUser_ : String -> Hook .
endfm

fmod TEST3 is
  protecting COMPAT .

  eq init =
    define 'localnames = readList "/etc/mail/local-host-names"
    .

  eq greeting =
    otherwise => reply 2 2 0 myHelo " Postmaster SMTP Daemon"
    .

  eq helo =
    always => reply 2 5 0 myHelo " Pleased to meet you."
    .

  eq mail =
    always => reply 2 5 0 from " ... sender ok"
    .

  eq rcpt =
    readAliases "/etc/mail/aliases"
    readVirtUser "/etc/mail/virtualusers"

    domain to == anyOf 'localnames =>
      {
      isUser (user to) => mbox user to
      }
    otherwise => reply 5 5 0 "user unknown"
    .

endfm
